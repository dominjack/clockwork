// build.rs
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use rand::{Rng, SeedableRng};
use rand::rngs::StdRng;

const Piece_count: usize = 12;



#[derive(Debug, Clone)]
pub struct ZobristKeys {
    pub piece_keys: [[u64; 64]; Piece_count],
    pub black_to_move_key: u64,
    pub castling_keys: [u64; 4],
    pub en_passant_keys: [u64; 8],
}

impl ZobristKeys{
    pub fn new() -> Self {
        let mut rng = StdRng::seed_from_u64(0xDEADBEEFCAFEBABEu64);

        let mut piece_keys = [[0u64; 64]; Piece_count];
        for piece in 0..Piece_count {
            for sq in 0..64 {
                piece_keys[piece][sq] = rng.random();
            }
        }

        let black_to_move_key = rng.random();

        let mut castling_keys = [0u64; 4];
        for i in 0..4 {
            castling_keys[i] = rng.random();
        }
        
        let mut en_passant_keys = [0u64; 8];
        for i in 0..8 {
            en_passant_keys[i] = rng.random();
        }

        ZobristKeys {
            piece_keys,
            black_to_move_key,
            castling_keys,
            en_passant_keys,
        }
    }
}



fn main() {
    println!("cargo:rerun-if-changed=build.rs");


    let keys = ZobristKeys::new();

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("zobrist_keys.rs");
    let mut f = File::create(&dest_path).unwrap();

    writeln!(f, "// This file is @generated by build.rs. Do not edit manually.").unwrap();
    //writeln!(f, "use crate::types::board::zobrist::ZobristKeys;").unwrap();
    // Or, if ZobristKeys definition is also generated / self-contained:
    // writeln!(f, "{}", ZOBRIST_STRUCT_DEFINITION_STRING).unwrap();


    writeln!(f, "pub static ZOBRIST_KEYS: ZobristKeys = ZobristKeys {{").unwrap();

    // Piece Keys
    writeln!(f, "    piece_keys: [").unwrap();
    for piece_idx in 0..keys.piece_keys.len() {
        write!(f, "        [").unwrap();
        for square_idx in 0..64 {
            write!(f, "0x{:x}u64, ", keys.piece_keys[piece_idx][square_idx]).unwrap();
        }
        writeln!(f, "],").unwrap();
    }
    writeln!(f, "    ],").unwrap();

    // Black to Move Key
    writeln!(f, "    black_to_move_key: 0x{:x}u64,", keys.black_to_move_key).unwrap();

    // Castling Keys
    write!(f, "    castling_keys: [").unwrap();
    for i in 0..keys.castling_keys.len() {
        write!(f, "0x{:x}u64, ", keys.castling_keys[i]).unwrap();
    }
    writeln!(f, "],").unwrap();

    // En Passant Keys
    write!(f, "    en_passant_keys: [").unwrap();
    for i in 0..keys.en_passant_keys.len() {
        write!(f, "0x{:x}u64, ", keys.en_passant_keys[i]).unwrap();
    }
    writeln!(f, "],").unwrap();

    writeln!(f, "}};").unwrap();

    
    // If your key generation depends on other files (e.g., a specific seed file),
    // you'd add `println!("cargo:rerun-if-changed=path/to/seed_file.txt");`
}